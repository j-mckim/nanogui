# FIXME - config via make-like args
# - (default)
# all
# webasm/emscripten (auto)
# debug

# FIXME - test target

# FIXME - install target should also include a pkg-config spec
# that, in turn, should be used when building the test code

# nb - as an aside, optparse doesn't accept '--no...' form arguments.

# CMakeLists.txt cruft
#
# NANOGUI_VERSION - only used in CMake's project(). Could use this for
# lib version, otherwise a nonce
#
# CMAKE_BUILD_TYPE - this can be one of 'Debug', 'Release',
# 'MinSizeRel', or 'RelWithDebInfo'. It's not used, except to add
# flags '-O3 -DNDEBUG' if REL.
#
# CMAKE_CONFIGURATION_TYPE - not used.
#
# NANOGUI_MASTER_PROJECT - if True, and the python module is being
# built, also builds docs.
#
# WIN32 (intrinsic) - sets NANOGUI_BUILD_GLAD_DEFAULT, adds library
# opengl32
#
# NANOGUI_BUILD_GLAD - defaults to NANOGUI_BUILD_GLAD_DEFAULT. Adds
# glad.c to the sources. For the shared lib, adds a couple CPP
# definitions, GLAD_GLAPI_EXPORT, GLAD_GLAPI_EXPORT_BUILD. And a bit
# more (FIXME elaborate).
#
# NANOGUI_BUILD_GLFW - runs a chunk of code at #217. It appears this
# compiles glfw source and adds the objects to the nanovg library.
#
# NANOGUI_BUILD_SHARED - NB - if True, add CPP flags NANOGUI_SHARED,
# NVG_SHARED. (FIXME verify these are actually used in the source
# code)
#
# NANOGUI_BUILD_EXAMPLES - runs a chunk of code at #554. QED.
#
# NANOGUI_BUILD_PYTHON - runs a chunk of code at #571. (FIXME - impl)

# FIXME testing
# libcester - header only, embedded, depends on nothing, current
#  cester.h
# tau
#  ~/src/tau

import os
import platform
from pprint import pprint # FIXME for debugging

# FIXME - need a replacement for bin2c.cmake, which is as follows:
'''
cmake_minimum_required (VERSION 2.8.12)

# Create header for C file
file(WRITE ${OUTPUT_C} "/* Autogenerated by bin2c */\n\n")
file(APPEND ${OUTPUT_C} "#include <stdint.h>\n\n")

# Create header of H file
file(WRITE ${OUTPUT_H} "/* Autogenerated by bin2c */\n\n")
file(APPEND ${OUTPUT_H} "#pragma once\n")
file(APPEND ${OUTPUT_H} "#include <stdint.h>\n\n")

string(REPLACE "," ";" INPUT_LIST ${INPUT_FILES})


# Iterate through binary files files
foreach(bin ${INPUT_LIST})
  # Get short filename
  string(REGEX MATCH "([^/]+)$" filename ${bin})
  # Replace filename spaces & extension separator for C compatibility
  string(REGEX REPLACE "\\.| |-" "_" filename ${filename})
  # Convert to lower case
  string(TOLOWER ${filename} filename)
  # Read hex data from file
  file(READ ${bin} filedata HEX)
  # Convert hex data for C compatibility
  string(REGEX REPLACE "([0-9a-f][0-9a-f])" "0x\\1," filedata ${filedata})
  # Append data to c file
  file(APPEND ${OUTPUT_C} "uint8_t ${filename}[] = {${filedata}};\n\nuint32_t ${filename}_size = sizeof(${filename});\n\n")
  # Append extern definitions to h file
  file(APPEND ${OUTPUT_H} "extern uint8_t ${filename}[];\n\nextern uint32_t ${filename}_size;\n\n")
endforeach()
'''
# FIXME - incorporate into a builder. Figure out a way to make both
# the .cxx and .h outputs depend on the .ttf sources. The .cxx and .h
# should go into the build directory. The .cxx is ephemeral. The .h
# should be in ~/include? Where is it needed in user apps? Maybe this
# should all be glommed into the Library step?
#
# def foo_build_function(target, source, env):
#     was_successful = None # did succeed
#     # ...
#     return was_successful

# foo_builder = Builder(action = foo_builder_function)
# env.Append(BUILDERS = { 'Foo': foo_builder })
# env.Foo('FIXME.foo', 'FIXME.input')
#
# e.g. multiple target (output)
# env.Command(target = ['a', 'b'], source = 'FIXME', action = FIXME_func)
#
# This would be in the form of a Builder or a Command, whose output
# would be this "nanogui_resources.[cpp, h]" file, in the build
# directory, but need to ensure it is searched. FIXME - also need to
# compile the .cpp file and add it to the lib.
#
# content of nanogui_resources.h e.g.
# extern const uint8_t fontawesome_solid_ttf[];
# extern uint32_t fontawesome_solid_ttf_size;
# ...
#
# content of nanogui_resources.cpp e.g.
# extern const uint8_t fontawesome_solid_ttf[] = {0x00,0x01,...
# uint32_t fontawesome_solid_ttf_size = sizeof(fontawesome_solid_ttf) - 1;
# ...

#
# bin2c - add_custom_command
#
# bin2c creates a compilable form of binary data that describe several
# fonts. Per platform, these are different. For Linux they are:
# fontnawesome_solid_ttf
# inconsolata_regular_ttf
# roboto_bold_ttf
# roboto_regular_ttf
# imageview_fragment_gles
# imageview_vertex_gles
#
# FIXME - glob the resources dir, or hard-code the desired fonts?
# CMakeLists.txt globs, based on which backend is being used. FIXME -
# add that code also. (also sets NANOGUI_USE_OPENGL)

# import re

### # FIXME omit
### 
### ngr_cxx_file = open('/tmp/nanogui_resources.cxx', 'w')
### ngr_h_file = open('/tmp/nanogui_resources.h', 'w')
### guard_name = '_nanogui_resources_h_'
### print(
###     '/* Autogenerated by scons */\n\n#include <cstdint>\n\n' ,
###     end = '',
###     file = ngr_cxx_file)
### 
### # FIXME - include the .h file in the .cxx file, then deprecate the
### # superfluous <stdint.h>. Better yet, native c++ int types? cstdint?
### 
### # FIXME use include guards rather than non-standard pragma once
### 
### print(
###     '''/* Autogenerated by scons */
### #pragma once
### #if !defined(%s)
### #define %s 1
### #include <cstdint>
### 
### ''' % (guard_name, guard_name),
###     end = '',
###     file = ngr_h_file)
### # FIXME do these need to be sorted? Doesn't look so.
### for ttf_fname in Glob('resources/*.ttf', strings = True):
###     # Synthesize a syntactically correct C++ identifier from the
###     # font's filename.
###     ttf_id = re.sub('[^\w]', '_', os.path.basename(ttf_fname).lower())
###     print('info: processing font', ttf_fname, 'as', ttf_id)
###     ttf_f = open(ttf_fname, mode = 'rb')
###     ttf_blob = ttf_f.read()
###     # print('ttf id', ttf_id)
###     print(
###         '''extern const uint8_t %s[%d]
### 
### extern uint32_t %s_size
### 
### ''' % (ttf_id, len(ttf_blob), ttf_id),
###         end = '',
###         file = ngr_h_file)
###     print(
###         'extern const uint8_t %s[%d] = {' % (ttf_id, len(ttf_blob)),
###         end = '',
###         file = ngr_cxx_file)
###     
###     # FIXME - this code writes out one less byte than the cmake
###     # version. CMake's extra byte appears to be nul (0x00) so may be a
###     # side effect of the cmake script always writing, say, an
###     # end-of-string nul. But is that then reflected in the
###     # 'sizeof(...) - 1' declarations? If so, I need to correct that in
###     # this script also.
### 
###     # FIXME - an item not yet clear - these declarations have to be
###     # used somewhere, and they are tied to specific names. Those names
###     # then must also be emplaced in the code that uses these
###     # data. Need to locate and resolve that.
###     
###     for b in ttf_blob:
###         # print(hex(b), end=',') # nb - not formatted
###         print('0x%02x' % (b), end = ',', file = ngr_cxx_file)
###         pass
###     ttf_f.close()
###     print(
###         '''};
### 
### uint32_t %s_size = sizeof(%s);
### 
### ''' % (ttf_id, ttf_id),
###         end = '',
###         file = ngr_cxx_file)
###     
###     # FIXME as noted, overkill
###     '''
###     ttf = ttLib.TTFont(ttf_fname) # FIXME open RO
###     print(ttf)
###     print(ttf['maxp'])
###     print(ttf['maxp'].numGlyphs)
###     print('keys', ttf.keys())
###     # print('gnames', ttf.getGlyphNames())
###     # getTableData(tag)
###     print('data', ttf.getTableData('glyf'))
###     '''
###     
###     pass
### print('#endif // %s' % (guard_name), end = '', file = ngr_h_file)
### ngr_h_file.close()
### ngr_cxx_file.close()
### print("FIXME debug exit"); Exit(0)
### # FIXME omit end

### # FIXME - move to SConstruct
### def synthesize_resources_files(target, source, env):
###     # Synthesize the target nanogui_resources.[cxx, h] files, based on
###     # the given font files. nb - 'targets' is ignored; output
###     # filenames are hard-coded.
###     did_fail = True
###     for t in target:
###         print('XXXX target', t.rstr())
###         # print('XXXX target', t.variant_dirs())
###     # FIXME - these are being created in the wrong place; the
###     # invocation directory rather than the variant directory.
###     ngr_cxx_file = open('nanogui_resources.cxx', 'w') # FIXME errcheck
###     # print('info: writing', ngr_cxx_file.name())
###     print('info: writing', ngr_cxx_file)
###     ngr_h_file = open('nanogui_resources.h', 'w') # FIXME errcheck
###     cpp_guard_name = '_nanogui_resources_h_'
###     print(
###         '/* Autogenerated by scons */\n\n#include <cstdint>\n\n' ,
###         end = '',
###         file = ngr_cxx_file)
###     print(
###         '/* Autogenerated by scons */\n#pragma once\n#if !defined(%s)\n#define %s 1\n#include <cstdint>\n' % (cpp_guard_name, cpp_guard_name),
###         end = '',
###         file = ngr_h_file)
###     for ttf_fobj in source:
###         ttf_fname = ttf_fobj.rstr()
###         # Synthesize a lexically correct C++ identifier from the
###         # font's filename.
###         ttf_id = re.sub('[^\w]', '_', os.path.basename(ttf_fname).lower())
###         print('info: processing font file', ttf_fname, 'as', ttf_id)
###         ttf_f = open(ttf_fname, mode = 'rb') # FIXME errcheck
###         ttf_blob = ttf_f.read()
###         print(
###             'extern const uint8_t %s[%d];\nextern uint32_t %s_size;\n' % (ttf_id, len(ttf_blob), ttf_id),
###             end = '',
###             file = ngr_h_file)
###         print(
###             'extern const uint8_t %s[%d] = {' % (ttf_id, len(ttf_blob)),
###             end = '',
###             file = ngr_cxx_file)
###         for b in ttf_blob:
###             # print(hex(b), end=',') # nb - not formatted
###             print('0x%02x' % (b), end = ',', file = ngr_cxx_file)
###             pass
###         ttf_f.close()
###         print(
###             '};\nuint32_t %s_size = sizeof(%s);\n' % (ttf_id, ttf_id),
###             end = '',
###             file = ngr_cxx_file)
###         pass # for ttf_fname
###     print('#endif // %s' % (cpp_guard_name), end = '', file = ngr_h_file)
###     ngr_h_file.close()
###     ngr_cxx_file.close()
###     did_fail = False
###     return did_fail
###     pass # synthesize_resources_files

### # FIXME switch/case?
### if True: # OpenGL
###     backend_defs = ['NANOGUI_USE_OPENGL']
###     glob = env.Glob('resources/*.ttf', strings = True) # FIXME rename
###     pass


# pkg-config elements

# install work
# - libraries
# - header
# - pkg-config info
#
# prefix=
# exec_prefix=
# libdir=
# includedir=
# Name:
# Description:
# Version:
# URL:
# Requires: (n/a)
# Requires.private: (n/a)
# Conflicts: (n/a)
# Libs:
# Libs.private:
# Cflags:
#
# cmake find module (if separate from pkg-config)
# LIBNANO_INCLUDE_DIRS
# LIBNANO_LIBRARIES
# LIBNANO_DEFINITIONS
# LIBNANO_LIBRARY_DIRS
#
# git remote show origin [to fetch url]
#
# wrt emscripten ports, there is no obvious place to put external
# packages (emscripten calls these 'ports').

# FIXME package builder?

# Run in parallel by default.

# FIXME - omitted; this doesn't work because scons 'helpfully'
# provides a default 'num_jobs' if it isn't specified by the
# user. There may not be a nice way to test fort this. The ugly way
# would be to check the raw command line for '-j' or '--jobs' and also
# check the environment for $NUM_CPU.
#
# not ('-j' in sys.argv or '--jobs' in sys.argv or 'NUM_CPU' in os.environ)

if False and not GetOption('num_jobs'): # FIXME not right, defaults to '1'
    SetOption('num_jobs', len(os.sched_getaffinity(0)))
# print('info: jobs:', GetOption('jobs'))
print('info: parallel builds:', GetOption('num_jobs'))

# FIXME option --prefix? (for install)

# Determine which library targets need to be built. By default, all.
AddOption(
    '--xdebug',
    action = 'store_true',
    help = 'Build debug version(s).',
)
AddOption(
    '--xrelease',
    action = 'store_true',
    help = 'Build release version(s).',
)
AddOption(
    '--xwebasm',
    action = 'store_true',
    help = 'Build WebAsm version(s).',
)
AddOption(
    '--xnative',
    action = 'store_true',
    help = 'Build native version(s).',
)

# xplat = ARGUMENTS.get('OS', Platform())
# print('xplat', xplat) # posix

env_common = Environment(
    CCFLAGS = [
        '-Wextra',
        '-Wall'],
    CXXFLAGS = [
        # '-std=c++17',
        '-std=c++2a',
        '-Wextra',
        '-Wall'],
    # FIXME - just for building apps
    LINKFLAGS = [ '-Wl,--demangle' ],
)

build_debug = False
build_release = False
if GetOption('xdebug'):
    build_debug = True
    if GetOption('xrelease'):
        build_release = True
else:
    if GetOption('xrelease'):
        build_release = True
    else:
        build_debug = True
        build_release = True
build_native = False
build_webasm = False
# env_common = Environment(FIXME-defaults)
# FIXME do Configure() checks here (if any)
# conf = Configure(env)
# conf.CheckCHeader()
# conf.CheckFunc()
# conf.CheckLib()
# conf.CheckLibWithHeader()
# conf.CheckType()
# glfw3
# stdint.h?
# pybind11?
# string.h (memset) - better choice?
# env_common = conf.Finish()
if GetOption('xnative'):
    build_native = True
    if GetOption('xwebasm'):
        # env = env_common.Clone(...)
        # Export(env)
        # SConscript(...)
        build_webasm = True
else:
    if GetOption('xwebasm'):
        build_webasm = True
    else:
        # neither true
        build_native = True
        build_webasm = True

# source files
libnanogui_example_files = [
    'src/example1.cpp',
    'src/example2.cpp',
    'src/example3.cpp',
    'src/example4.cpp',
    'src/example_icons.cpp',
    ]
libnanovg_source_files = [
    'ext/nanovg/src/nanovg.c'
]
libnanogui_source_files = [
    'src/button.cpp',
    'src/canvas.cpp',
    'src/checkbox.cpp',
    'src/colorpicker.cpp',
    'src/colorwheel.cpp',
    'src/combobox.cpp',
    'src/common.cpp',
    'src/graph.cpp',
    'src/imagepanel.cpp',
    'src/imageview.cpp',
    'src/label.cpp',
    'src/layout.cpp',
    'src/messagedialog.cpp',
    'src/opengl.cpp',
    'src/popupbutton.cpp',
    'src/popup.cpp',
    'src/progressbar.cpp',
    'src/renderpass_gl.cpp',
    'src/screen.cpp',
    'src/shader.cpp',
    'src/shader_gl.cpp',
    'src/slider.cpp',
    'src/tabwidget.cpp',
    'src/textarea.cpp',
    'src/textbox.cpp',
    'src/texture.cpp',
    'src/texture_gl.cpp',
    'src/theme.cpp',
    'src/traits.cpp',
    'src/vscrollpanel.cpp',
    'src/widget.cpp',
    'src/window.cpp',
]

# FIXME - caveat summation of below comment: 'scons -u' only builds
# content at or below the current CWD. It must be invoked from the TLD
# and/or the library must be built below the CWD.
#
# FIXME - this works when invoked from the TLD, creating the library
# in the TLD. It doesn't work via 'scons -u' from a lower
# directory. It silently compiles all the .o files but the final lib
# is not created. A hint as to why the other Library() directives
# fail.
'''
env_common.StaticLibrary(
    target = 'xx_common_nanogui',
    # source = ['build_Linux_x86_64_debug/src/t.cxx'] # fails, no lib
    source = ['src/t.cxx'] # fails, no .o, no lib
)
'''

# FIXME regarding platform: is it better to use e.g. sys? or os? The
# platform module is described as using values determined during the
# last build of the Python interpreter running the script. In this
# code, the main purpose so far is to determine what system
# dependencies are necessary (GL libraries, etc.). These would
# typically be established by the same source that provided the Python
# interpreter, so in that light platform is the best choice.

if False and build_native: # FIXME temp omit

    # FIXME both shared and static
    platform_system = platform.system()
    target_name = platform_system + '_' + platform.machine()
    env_native = env_common.Clone()

    if platform_system == 'Darwin':
        # FIXME add libs suitable for OSX
        pass
    elif platform_system == 'Linux':
        env_native.AppendUnique(
            # Libraries needed for building examples.
            LIBS = ['GL', 'glfw', 'pthread'],
        )
        pass
    elif platform_system == 'Windows':
        # FIXME add libs suitable for MSWin
        pass
    else:
        # FIXME diagnostic, unrecognized platform
        pass
    
    # FIXME build python module

    # FIXME - slightly different invocations for glfw, nanogui
    
    # FIXME - following CLI options are present in cmake's version

    # Thoughts on how best to compile
    # - library composed of sources from multiple directories.
    # - per directory/group, different compile options (defines)
    #
    # - use singular SConstruct
    #  - + all in one place
    #  - - longer, messier SConstruct, can't use relative paths
    # - per directory SConscript
    #  - creating the library is complex, must be one once only
    #   - best done in top level SConstruct
    #    - disconnect between SConscript, which compiles and
    #      SConstruct, which assumes all the .o files are present
    #      (compiled)
    #  - need to get list of .o files
    #   - ideally, provided by SConscript - can it pass back an array?
    #
    # Additional complicating factor: considering the number of
    # variants, each potentially requiring a different version of
    # SConscript, this is getting out of control. More sense to do all
    # in the top level script, using inate python capabilities.
    # axes:
    # - debug/production
    # - static/shared
    # - native/webase/other?
    # - disparate source directories/groups (nanovg, nanogui, others?)

    # Can env.Library() take e.g. CCFLAGS, etc.?

    # FIXME - this fails to build imageview.o, with the diagnostics:
    # 'imageview_vertex_gl' was not declared in this scope
    # 'imageview_fragment_gl' was not declared in this scope
    # 'imageview_vertex_gl_size' was not declared in this scope
    # 'imageview_fragment_gl_size' was not declared in this scope
    #
    # These appear to part of a GL shader, not the main source
    # code. They result from these macros:
    # NANOGUI_SHADER(imageview_vertex), NANOGUI_SHADER(imageview_fragment)
    #
    # Macro NANOGUI_SHADER is defined in shader.h, three different
    # versions, based on the target being gl, gles, or metallib
    #
    # Possibly the wrong version of GL is being used? Because of a
    # missing or out-of-place include search path member?
    #
    # Aha - it shows up in cmake's nanogui_resources.[.h, .cpp],
    # missing from this scons version. Need:
    # extern const uint8_t imageview_fragment_gles[];
    # extern uint32_t imageview_fragment_gles_size;
    # extern const uint8_t imageview_vertex_gles[];
    # extern uint32_t imageview_vertex_gles_size;

    # These are defined in cmake's nanogui_resources.cpp; a big blob
    # and its size. They are derived from shader source code in one
    # of:
    # resources/imageview_vertex.[gles, metal, gl]
    #
    # From cmake:
    # /usr/bin/c++  -DNANOGUI_BUILD -DNANOGUI_SHARED -DNANOGUI_USE_OPENGL -DNVG_BUILD -DNVG_SHARED -DNVG_STB_IMAGE_IMPLEMENTATION -D_GLFW_BUILD_DLL -I/home/jim/src/nanogui/build-cmake-2 -I/home/jim/src/nanogui/include -I/home/jim/src/nanogui/ext/nanovg/src -I/home/jim/src/nanogui/ext/glfw/include  -Wall -Wextra -O3 -DNDEBUG -flto -fno-fat-lto-objects -fPIC -fvisibility=hidden   -march=nehalem -std=gnu++17 -o CMakeFiles/nanogui.dir/src/imageview.cpp.o -c /home/jim/src/nanogui/src/imageview.cpp
    #
    # From scons:
    # g++ -o build_Linux_x86_64_debug/src/imageview.o -c -std=c++2a -Wextra -Wall -g -Og -Wextra -Wall -g -Og -D_GLFW_BUILD_DLL -DNANOGUI_BUILD -DNANOGUI_SHARED -DNANOGUI_USE_OPENGL -DNDEBUG -DNVG_BUILD -DNVG_SHARED -DNVG_STB_IMAGE_IMPLEMENTATION -Iinclude -Iext/nanovg/src -Ibuild_Linux_x86_64_debug/src -Isrc src/imageview.cpp
    
    if build_debug:
        print('info: building native debug target', target_name)
        env = env_native.Clone()
        env.AppendUnique( # CPPDEFINES = ['NANOGUI_USE_OPENGL'],

            # FIXME - some of the below flags are common to both debug
            # and release. Some are common to both local and webasm.
            
            # FIXME - how many of these are needed? Deprecate the
            # rest. Move the bunch up to the common base environment.
            CPPDEFINES = [
                # Define if building GLFW and as part of a shared
                # library. It appears to be
                # Microsoft-compiler-specific. [copy CMake]
                '_GLFW_BUILD_DLL',
                
                # Referenced in common.h [copy CMake]
                'NANOGUI_BUILD',
                
                # Referenced in opengl.h, common.h [copy CMake]
                'NANOGUI_SHARED',
                
                # Per target architecture, this or one if its kin
                # (GLES, METAL) must be defined
                'NANOGUI_USE_OPENGL',
                
                # Referenced in opengl_check.h, screen.cpp,
                # renderpass_gl.cpp, renderpass_metal.mm [copy CMake
                # and/or enable for debug but not for
                # production]. Appears to enable additional error
                # checking; macro CHK(), enables flag NVG_DEBUG. Flag
                # NVG_DEBUG does not appear to be used; a nonce.
                #
                # nb - some of the error checking involves throwing an
                # exception, so exceptions should be enabled for the
                # webasm target.
                'NDEBUG',
                
                # Not used?
                'NVG_BUILD',
                
                # Not used?
                'NVG_SHARED',
                
                # Not used?
                'NVG_STB_IMAGE_IMPLEMENTATION',
            ],
            CPPPATH = ['#include', '#ext/nanovg/src', 'src'],
            CCFLAGS = ['-g', '-Og'],
            CXXFLAGS = ['-g', '-Og'],
        )
        #print(env.Dump()); Exit(0)
        # print('CXXFLAGS', env['CXXFLAGS']); Exit(0) # works

        # FIXME this strategy doesn't work. Arrays or lists of objects
        # can't be conveyed from SConscript sub-scripts.

        # FIXME VariantDir is not working as expected. The results of
        # compiles are not being placed in said directory, but in the
        # source directory.
        #
        # VariantDir() is a method of Scons.Environment.Base.
        #
        # In turn, it invokes self.fs.VariantDir().
        #
        # Which is an object that contains .SConstruct_Dir', whose
        # value is '.'.
        #
        # The fs object is reported to be SCons.Node.FS.FS. However,
        # it only contains a few data, and not, e.g. get_abspath().
        #
        # env.fs.VariantDir?
        #
        # comments at
        # https://stackoverflow.com/questions/1074062/why-does-scons-variantdir-not-put-output-in-the-given-directory
        # are helpful.  either a separate SConscript must be used (can
        # be in the same directory), or the outputs must all include
        # the variant dir's path. For the latter, that would
        # presumably include all the .o files; ugh. So, the former:
        #
        variant_dir = 'build_' + target_name + '_debug'
        env['libnanogui_sources'] = libnanovg_source_files + libnanogui_source_files
        env['nanogui_example_sources'] = libnanogui_example_files
        env.SConscript(
            'SConscript',
            src_dir = '.',
            variant_dir = variant_dir,
            exports = 'env',
            duplicate = False,
            must_exist = True)
        '''
        env.StaticLibrary(
            target = 'xxnanogui',
            # source = ['build_Linux_x86_64_debug/src/t.cxx'] # fails, no lib
            source = ['src/t.cxx'] # fails, no .o, no lib
        )
        '''

        '''
        # FIXME - below is a little problematic: feeding both nanovb
        # and nanogui in via the same environment means they both get
        # the same flags, same include search paths, etc. This might
        # be workable. The wordier alternative would be to create a
        # list of objects, each member with the necessary
        # environment. One saving grace is that nanovg is C, nanogui
        # is C++; in that, they can get different compilation
        # environments.
        env.VariantDir(
            src_dir = '.',
            variant_dir = variant_dir,
            duplicate = False)
        # print('constr', env.fs['SConstruct_dir']); Exit()
        # print('constr', env.fs.SConstruct_dir); Exit()
        # pprint(vars(env.fs)); Exit()
        # print(env.fs.get_abspath()); Exit()
        # pprint(vars(env)); Exit()
        # FIXME - '.o' below is not platform neutral
        # FIXME - this Command() should be part of the base environment
        # env.Command(target = None, source = None, action = "/bin/xfalse XYZZY")
        # env.Command(target = None, source = None, action = synthesize_resources_files)
        env.Command(
            ['#nanogui_resources.cxx', '#nanogui_resources.h'],
            source = env.Glob('resources/*.ttf'),
            action = synthesize_resources_files)
        # FIXME - if not for the _debug suffix, this could be part of
        # the base environment, rather than cluttering up all the
        # builds.
        env.Library(
            variant_dir + '/nanogui_debug',
            source = libnanovg_source_files + libnanogui_source_files)
        #
        # FIXME - putting the above into a function might be useful
        '''
        '''
        objs = []
        # Export(env) # as env
        objs += env.SConscript(
            dirs = 'ext/nanovg/src', # FIXME platform independent?
            duplicate = False,
            exports = 'env',
            must_exist = True,
            # name = 'FIXME',
            variant_dir = 'build_' + target_name + '_debug',
        )
        # FIXME - and for src
        # objs += env.debug...
        # FIXME - finally, env.Library('nanogui', [objs...])
        env.Library('nanogui_debug', objs)
        '''
        
        
        # env.Install(...)

        # VariantDir('build-xxx', 'src', duplicate = False)
        # env.Program([FIXME-sources])

        # with the variant dir
        # env.Library(target = 'nanogui_debug', source = [ ... ])
    if build_release:
        print('warning: build_release not implemented')
        pass # FIXME temp omit
        env = env_native.Clone()
        env.AppendUnique(
            CCFLAGS = ['-O3'],
            CXXFLAGS = ['-O3'],
        )
        print('info: building native release target', target_name)
        # FIXME env = env_native.Clone(...)
        # VariantDir('build-xxx', 'src', duplicate = False)
        # env.Program([FIXME-sources])
        # env.Install(FIXME)
        # env.InstallVersionedLib(FIXME)
        # env.Package(FIXME)
    # FIXME - finally, build python module
    pass # build_native

if build_webasm:
    # print('warning: build_webasm not implemented')
    # pass # FIXME temp omit

    # FIXME only static

    # FIXME - flags of interest
    # -O0 (debug)/-O3 (release) [maybe -Oz]
    # -s ...=... (FIXME - get this from src/settings.js)
    #  ASSERTIONS=0 (release)
    #  RUNTIME_LOGGING=1 (debug)
    #  DISABLE_EXCEPTION_CATCHING=0
    #  NODEJS_CATCH_EXIT=0
    #  FIXME - throw/catch support?
    #  FIXME - GL support (version)?
    #  FIXME - threads? (-pthread)
    # --tracing (?)
    # -flto (production)
    # --closure=1

    target_name = 'emscripten_webasm'
    # The method preferred by the emscripten compiler developers for
    # determining the location of all the relevant executables is to
    # find the path to one, then prepend it to all the others.
    emcxx_path = WhereIs('em++')
    if emcxx_path:
        em_root = os.path.dirname(emcxx_path)
        print("info: using emscripten suite from '%s'" % em_root);
        env_webasm = env_common.Clone(
            AR = os.path.join(em_root, 'emar'),
            CC = os.path.join(em_root, 'emcc'),
            CXX = os.path.join(em_root, 'em++'),
            # PROGSUFFIX = [".html", ".js"][1], # FIXME resolve
            RANLIB = os.path.join(em_root, 'emranlib'),
        )
        env_webasm.AppendUnique(
            # Libraries needed for building examples.
            CPPDEFINES = [
                # Referenced in common.h [copy CMake]
                'NANOGUI_BUILD',
                
                # Referenced in opengl.h, common.h [copy CMake]
                # 'NANOGUI_SHARED',
                
                'NANOGUI_USE_OPENGL',
                
                'NDEBUG', # FIXME move to build_debug
                
                # Not used?
                'NVG_BUILD',
                
                # Not used?
                'NVG_STB_IMAGE_IMPLEMENTATION',
            ],
            CPPPATH = ['#include', '#ext/nanovg/src', 'src'],
            LIBS = ['GL', 'glfw', 'pthread'], # FIXME probably not right; review cmake script
        )
        variant_dir = 'build_webasm_emscripten'
        if build_debug:
            print('info: building webasm debug target', target_name)
            # print('warning: webasm build_debug not implemented')
            # FIXME env = env_webasm.Clone(...)
            env = env_webasm.Clone()
            env['libnanogui_sources'] = libnanovg_source_files + libnanogui_source_files
            env.SConscript(
                'SConscript',
                src_dir = '.',
                variant_dir = variant_dir,
                exports = 'env',
                duplicate = False,
                must_exist = True)
        if build_release:
            print('info: building webasm release target', target_name)
            print('warning: webasm build_release not implemented')
            # FIXME env = env_webasm.Clone(...)
    else:
        print('warning:', target_name, 'target will not be built; compiler (em++) not found')
    pass # build_webasm

# production/release
# docs
# install
#
# FIXME - these can also be done via command-line options,
# AddOption(). Which would be better? Scons provides no way to get a
# list of options, only a way to get them by name. It doesn't complain
# when non-existant options are used. nb - not well documented;
# AddOption takes several args but there's no explanation wrt
# them. Documented in 'pydoc optparse'
#
# FIXME - also via ARGUMENTS.get() (dictionary), or ARGLIST
# https://scons.org/doc/1.0.0/HTML/scons-user/x2318.html
# nb - '--debug' is not available, already used by scons
#
# FIXME - also via COMMAND_LINE_TARGETS
# https://scons.org/doc/production/HTML/scons-user/ch10s03.html
# This needs more investigation - Each of these have must be
# enumerated as a bona-fide target (Program, Library, etc.)?
# env.Alias() to create a named target

# Install builder
# env.Install('dest-dir', [program_objs])
# env.InstallAs(...)

# Variant directory tree
# https://scons.org/doc/1.0.0/HTML/scons-user/c3221.html
# e.g. SConscript('src/SConscript', variant_dir='build')
# e.g. SConscript('src/SConscript', variant_dir='build', duplicate=0)
# or sans SConscript, VariantDir
# e.g.:
# VariantDir('build', 'src', duplicate=0)
# env = Environment()
# env.Program('build/hello.c')

# env.Install()
# env.StaticLibrary() (aka Library)
# env.StaticObject() (aka Object)
# env.Program() (for tests)
#
# Library('nanogui', [FIXME sources.cxx])

# Review of cmake process
# - compile ext/glfw source code
# - bin2c ?
# - compile nanovg/src objects
# - create library libnanogui.so
# - build examples
# - compile python API/module

# cmake's flags, native, from 'make --trace'
#
# glfw (c)
# /usr/bin/cc
# -D_GLFW_BUILD_DLL
# -D_GLFW_USE_CONFIG_H
# -I/home/jim/src/nanogui/ext/glfw/include
# -I/home/jim/src/nanogui/ext/glfw/src
# -I/home/jim/src/nanogui/build-cmake-2/ext/glfw/src
# -O3
# -DNDEBUG
# -fPIC
# -march=nehalem
# -Wall
# -fvisibility=hidden	### recommended for shared objects, better link time
# -Wdeclaration-after-statement
# -o CMakeFiles/glfw_objects.dir/context.c.o
# -c /home/jim/src/nanogui/ext/glfw/src/context.c
#
# nanogui
# /usr/bin/c++
# -DNANOGUI_BUILD	### not used?
# -DNANOGUI_SHARED	### not used?
# -DNANOGUI_USE_OPENGL	### shader.h, screen.cpp, many others
# -DNVG_BUILD		### nanovg.h
# -DNVG_SHARED		### nanovg.h
# -DNVG_STB_IMAGE_IMPLEMENTATION	### not used?
# -D_GLFW_BUILD_DLL	### glfw3.h, x11_init.c, others
# -I/home/jim/src/nanogui/build-cmake-2
# -I/home/jim/src/nanogui/include
# -I/home/jim/src/nanogui/ext/nanovg/src
# -I/home/jim/src/nanogui/ext/glfw/include
# -Wall
# -Wextra
# -O3
# -DNDEBUG		### opengl_check.h, screen.cpp, renderpass_gl.cpp
# -flto			### run standard link-time optimizer (release)
# -fno-fat-lto-objects	### omit, dubious
# -fPIC
# -fvisibility=hidden
# -march=nehalem
# -std=gnu++17
# -o CMakeFiles/nanogui.dir/src/checkbox.cpp.o
# -c /home/jim/src/nanogui/src/checkbox.cpp

# cmake's flags, wasm, from 'make --trace'
#
# glfw
# home/jim/src/emsdk/upstream/emscripten/emcc
# -DNANOGUI_BUILD
# -DNANOGUI_GLES_VERSION=2	### opengl.h, scren.cpp, renderpass_gl.cpp, others
# -DNANOGUI_USE_GLES	### opengl.h, renderpass.h, shader.h, texture.h, others
# -DNVG_STB_IMAGE_IMPLEMENTATION
# @CMakeFiles/nanogui.dir/includes_C.rsp
#  -I/home/jim/src/nanogui/build-cmake
#  -I/home/jim/src/nanogui/include
#  -I/home/jim/src/nanogui/ext/nanovg/src
# -O3
# -DNDEBUG
# -O3
# -DNDEBUG
# -march=nehalem
# -o CMakeFiles/nanogui.dir/ext/nanovg/src/nanovg.c.o
# -c /home/jim/src/nanogui/ext/nanovg/src/nanovg.c
#
# nanogui
# /home/jim/src/emsdk/upstream/emscripten/em++
# -DNANOGUI_GLES_VERSION=2
# -DNANOGUI_USE_GLES
# @CMakeFiles/example_icons.dir/includes_CXX.rsp
# -O3
# -DNDEBUG
# -fvisibility=hidden
# -O3
# -DNDEBUG
# -march=nehalem
# -std=gnu++17
# -o CMakeFiles/example_icons.dir/src/example_icons.cpp.o
# -c /home/jim/src/nanogui/src/example_icons.cpp

Help("""
FIXME additional help content
""", append = True)

# FIXME dump architecture

# FIXME - process command line options


# FIXME - these two are part of the same library, so probably need to
# be in the same Library(), same SConscript (unless there's a way for
# Library() to replace/update.
#
# NB - see 14.5.3
# https://scons.org/doc/production/HTML/scons-user/ch14s05.html
# for a depiction of how to create a list of objects (source files)
# from multiple SConscripts and create a library from them. Exactly
# what is needed.


# For local (vs. webasm) builds
# env = Environment()
# conf = Configure(env)
## Checks for libraries, header files, etc. go here!
# conv.CheckCHeader('math.h') # etc.
## CheckFunc()
## CheckLib()
## CheckType()
# env = conf.Finish()

# FIXME - investigate Tools - would it be practical to define
# e.g. 'webasm' to set the appropriate builder variables? ($CC, etc.)

# FIXME - builder methods for
# - creation of requisist libraries (targets, debug/release, shared/static)
#     Library('x', ['x1.cxx', 'x2.cxx'])
#     StaticLibrary('x', ['x1.cxx', 'x2.cxx'])
# - docs?
# - test
# - install
#
# for all the targets (local, webasm)
#  if compiler is available
#   for all the modes (debug, release)
#    build that target
#

# import subprocess # FIXME deprecate

# print(COMMAND_LINE_TARGETS)
for target in COMMAND_LINE_TARGETS:
    print(target)
    pass
# For each target
#  is it valid?
#  do the relevant work
#exit(0)

# FIXME - just for testing; if emscripten, target name 'emscripten_webasm'
target_name = platform.system() + '_' + platform.machine()
if 'EMSCRIPTEN_TOOL_PATH' in os.environ:
    # import EMSCRIPTEN_TOOL_PATH/emscripten.py
    # FIXME this can silently fail
    ''' # FIXME temp omit
    tpn = os.environ.get('EMSCRIPTEN_TOOL_PATH')
    print('tpn ', tpn)
    env = Environment(toolpath=[os.environ.get('EMSCRIPTEN_TOOL_PATH')])

    # importlib.import_module(os.environ.get('EM_CONFIG'))
    # print(EM_CONFIG); exit()
           
    # FIXME - this is supposed to run the given script
    # (e.g. emscripten.py in the tool path. Given the value
    # 'emscripten', it fails with the diagnostic:
    #
    # TypeError: exceptions must derive from BaseException:
    #   File "/home/jim/src/nanogui/SConstruct", line 21:
    #     env.Tool('emscripten') # FIXME necessary?
    #   File "/usr/lib/scons/SCons/Environment.py", line 1810:
    #     tool(self)
    #   File "/usr/lib/scons/SCons/Tool/__init__.py", line 303:
    #     self.generate(env, *args, **kw)
    #   File "/home/jim/src/emsdk/upstream/emscripten/tools/scons/site_scons/site_tools/emscripten/emscripten.py", line 17:
    #     raise 'Unable to find emscripten. Please set EMSCRIPTEN_ROOT'
    #
    # Given any other value, it fails with:
    #
    # SConsEnvironmentError: No module named ...:
    #
    # Two problems:
    # EMSCRIPTEN_ROOT must be set
    #
    # (minor) exceptions must derive from BaseException; possible
    # python2/python3 issue
    #
    # In this test case, EMSCRIPTEN_ROOT =
    # '/home/jim/src/emsdk/upstream/emscripten'
    #
    # This issue has actually been logged,
    # https://github.com/emscripten-core/emscripten/issues/9685 but
    # not resolved. The gist is that scripts like the scons
    # emscripten.py configurator seem to rely on this being set (in
    # the shell env?). It's not set by default.
    #
    # FIXME - can it be extracted from em-config? It appears so.
    # em-config EMSCRIPTEN_ROOT
    # yields
    # /home/jim/src/emsdk/upstream/emscripten
    #
    # FIXME - if doable in scons, do so, otherwise python's
    # subprocess.check_output(...)
    # os.popen(command).read()
    # sp = subprocess.popen(['em-config', 'EMSCRIPTEN_ROOT'], check = True).getstatusoutput()

    # FIXME - ideally, the tool configurator (emscripten.py) would be
    # fixed to do this itself. The odd catch-22 is that, for this to
    # work, the command 'em-config' must be in the PATH. Which in turn
    # can be derived from EMSCRIPTEN_ROOT.

    # FIXME - this can also be obtained from importing $EM_CONFIG
    # (that is, the path defined by this shell variable). Probably
    # easier, as I think that is what em-config does anyway. NB -
    # comments on the emscripten-discuss group at google
    # https://groups.google.com/g/emscripten-discuss/c/WE-wtaRFpTE,
    # indicate emscripten maintainers would prefer that the script
    # ~/.emscripten (i.e. $EM_CONFIG) not be used (parsed), but rather
    # have root be determined via the path to an emscripten command
    # (i.e. 'emcc'). Under Linux, can be done by parsing '/bin/which
    # emcc'. Can this be done portably? (yes,
    # spawn.find_executable('str')) Perhaps the awkward process of
    # invoking em-config is the best solution.

    # This is a work-around to support the legacy 'emscripten.py' code
    # that is provided with emscripten. That code doesn't work
    # properly with the current version of emscripten. Until it gets
    # fixed, this enables it to work for this application.
    #
    # As noted in the build docs, this code requires the emscripten
    # 'em-config' command be present (i.e. be somewhere in PATH). If
    # the emscripten package was installed and configured per
    # emscripten's instructions, this will be the case.
    try:
        eroot = subprocess.check_output(
            ['em-config', 'EMSCRIPTEN_ROOT'],
            text = True).strip()
    except subprocess.CalledProcessError as ex:
        print('fatal error: command failed, ', ex.args)
        Exit(1)
    except FileNotFoundError as ex:
        print('fatal error: command could not be executed, ',
              ex.filename, ', ', ex.strerror);
        Exit(1)
    print('info: EMSCRIPTEN_ROOT = ', eroot)
    os.environ['EMSCRIPTEN_ROOT'] = eroot
    env.Tool('emscripten')
    '''
    
    # FIXME alternative to above (deprecate above)
    # replace following in env:
    # 'AR': '/home/jim/src/emsdk/upstream/emscripten/emar',
    # 'CC': '/home/jim/src/emsdk/upstream/emscripten/emcc',
    # 'CXX': '/home/jim/src/emsdk/upstream/emscripten/em++',
    # F03, F08, F77, F90, F95, FORTRAN, JAVAC: '/bin/false',
    # 'RANLIB': '/home/jim/src/emsdk/upstream/emscripten/emranlib',
    # OBJSUFFIX=[".js", ".bc", ".o"][2]
    # LIBSUFFIX=[".js", ".bc", ".o"][2]
    # PROGSUFFIX=[".html", ".js"][1]

    # The method preferred by the emscripten compiler developers for
    # determining the location of all the relevant executables is to
    # find the path to one, then prepend it to all the others.
    emcxx_path = spawn.find_executable('em++')
    if emcxx_path == None:
        print('fatal error: compiler (em++) not found')
        Exit(1)
    em_root = os.path.dirname(emcxx_path)
    print("info: using emscripten from '%s'" % em_root);
    env_webasm = env_common.Clone(
        AR = os.path.join(em_root, 'emar'),
        CC = os.path.join(em_root, 'emcc'),
        CXX = os.path.join(em_root, 'em++'),
        # CXX_FLAGS = ['-Wextra', '-Wall'],
        # PROGSUFFIX = [".html", ".js"][1], # FIXME resolve
        RANLIB = os.path.join(em_root, 'emranlib'),
    )
    # print(env_webasm.Dump())
    target_name = 'emscripten_webasm'

    # FIXME env.clone() for e.g. debug, release
    
print("info: target ", target_name)
# print(env)
#print(os.environ);

'''
SConscript(
    ['src/SConscript'],
    variant_dir='build_' + target_name,
    duplicate = 0)
'''

# Local Variables:
# mode: python
# End:
