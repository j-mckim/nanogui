Import('env')

import os
import re

def synthesize_pkg_config(target, source, env):
    # Synthesize a pkg-config file (e.g. yadayada.pc).

    # FIXME - this is based on where the files are installed; must be
    # part of or follow the install process. Do this based on the
    # existence of a prefix value in env?

    # # comment
    # prefix=...
    # libdir=...
    # includedir=...
    # Name: ...
    # Description: ...
    # Version: ...
    # URL: ...
    # Requires: ...
    # Conflicts: ...
    # Libs: -L... -l...
    # Libs.private: ...
    # Cflags: ...
    
    pass # synthesize_pkg_config

def synthesize_resources_files(target, source, env):
    # Synthesize the target .cxx and .h files, based on the given
    # (source) font files.
    did_this_fail = True
    cxx_target = None
    h_target = None
    # The supplied target is required to be an array of two filenames,
    # a .cxx and a .h. Determine which element is which.
    for t in target:
        if re.search('\.cxx$', t.rstr()):
            cxx_target = t
            pass
        elif re.search('\\.h$', t.rstr()):
            h_target = t
        else:
            print('error: target contains unrecognized file extension,', t.rstr())
            Exit(1)
        pass # for t
    if cxx_target == None or h_target == None:
        print('error: targets lack either .cxx or .h')
        Exit(1)
    ngr_cxx_file = open(cxx_target.get_path(), 'w') # FIXME errcheck
    print('info: writing', cxx_target.get_path())
    ngr_h_file = open(h_target.get_path(), 'w') # FIXME errcheck
    # Synthesize the guard pp macro from the header filename.
    cpp_guard_name = '_%s_' % (re.sub('[^\w]', '_', os.path.basename(h_target.get_path())))
    print(
        '/* Autogenerated by scons */\n'
        '#include <%s>\n' % (os.path.basename(h_target.get_path())) ,
        end = '',
        file = ngr_cxx_file)
    print(
        '/* Autogenerated by scons */\n'
        # '#pragma once\n'
        '#if !defined(%s)\n'
        '#define %s 1\n'
        '#include <cstdint>\n' % (cpp_guard_name, cpp_guard_name),
        end = '',
        file = ngr_h_file)
    for ttf_fobj in source:
        ttf_fname = ttf_fobj.rstr()
        # Synthesize a lexically correct C++ identifier from the
        # font's filename.
        ttf_id = re.sub('[^\w]', '_', os.path.basename(ttf_fname).lower())
        print('info: processing font file', ttf_fname, 'as', ttf_id)
        ttf_f = open(ttf_fname, mode = 'rb') # FIXME errcheck
        ttf_blob = ttf_f.read()
        print(
            'extern const uint8_t %s[%d];\n'
            'extern uint32_t %s_size;\n' % (ttf_id, len(ttf_blob), ttf_id),
            end = '',
            file = ngr_h_file)
        print(
            'const uint8_t %s[%d] = {' % (ttf_id, len(ttf_blob)),
            end = '',
            file = ngr_cxx_file)
        for b in ttf_blob:
            print('0x%02x' % (b), end = ',', file = ngr_cxx_file)
        ttf_f.close()
        print(
            '};\n'
            'uint32_t %s_size = sizeof(%s);\n' % (ttf_id, ttf_id),
            end = '',
            file = ngr_cxx_file)
        pass # for ttf_fobj
    print('#endif // %s' % (cpp_guard_name), file = ngr_h_file)
    ngr_cxx_file.close()
    ngr_h_file.close()
    did_this_fail = False
    return did_this_fail
    pass # synthesize_resources_files

env.Command(
    # FIXME - the targets need to be part of the dependencies
    # (i.e. source Node) for the Library(), not hard-coded here.
    target = ['src/nanogui_resources.cxx', 'src/nanogui_resources.h'],
    source = env.Glob('resources/*.ttf') + env.Glob('resources/*.gl'), # FIXME per target architecture
    action = synthesize_resources_files
    )

static_lib = env.StaticLibrary(
    target = 'nanogui',
    source = ['src/nanogui_resources.cxx'] + env.get('libnanogui_sources', [])
)

# FIXME thoughts: may not wish to build both a static and a shared
# library for all profiles (release, debug). For webasm, only static
# makes sense. How best to manage this?  Not having both could also
# complicate install and package operations. If the overhead of static
# linking is sufficiently small, the shared library under any
# circumstance doesn't make sense. Shared library may also require
# PIC.

# FIXME temp omit, as noted above
False and env.SharedLibrary(
    target = 'nanogui',
    source = ['src/nanogui_resources.cxx'] + env.get('libnanogui_sources', [])
)

# FIXME build python module if requested

example_sources = env.get('nanogui_example_sources', [])
if example_sources:
    emrun_friendly = env.get('emrun_friendly', False)
    env_ex = env.Clone()
    # The example_icons program takes a long time to compile unless we
    # request no var tracking. Ultimately, tracking can't be used
    # anyways.
    env_ex.AppendUnique(CXXFLAGS = '-fno-var-tracking')
    for example_source in example_sources:
        # FIXME plus whatever compiler options, pp defines, etc.
        # FIXME plus whatever platform-specific libraries are required
        # target = os.path.splitext(os.path.basename(example_source))[0]
        target = os.path.splitext(example_source)[0]
        if emrun_friendly:
            # This only applies to emscripten/webasm. We are being
            # directed to create a emrun-friendly webasm app; one that
            # can be easily tested via command line 'emrun'. Append a
            # .html suffix to the target to cause the emscripten
            # compiler-linker to do so.
            target += '.html'
        print('DEBUG: source', example_source, 'target', target)
        env_ex.PrependUnique(
            LIBS = [
                static_lib,
            ],
        )
        env_ex.Program(
            target = target,
            source = example_source,
        )
        pass # for example_source

# Local Variables:
# mode: python
# End:
